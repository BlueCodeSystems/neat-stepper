name: Maintain JitPack badges
on:
  push:
    branches: ["master"]
    tags: ["**"]
  workflow_dispatch: {}
jobs:
  update-badges:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute values
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          IFS='/' read -r OWNER REPO <<<"${GITHUB_REPOSITORY}"
          git fetch --tags --force --prune 2>/dev/null || true
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          echo "owner=$OWNER" >> "$GITHUB_OUTPUT"
          echo "repo=$REPO" >> "$GITHUB_OUTPUT"
          echo "latest_tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"

      - name: Resolve branch to push
        id: branch
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_REF_TYPE:-}" == "branch" && -n "${GITHUB_REF_NAME:-}" ]]; then
            BR="$GITHUB_REF_NAME"
          else
            BR=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p' || true)
            if [ -z "$BR" ]; then BR="master"; fi
          fi
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      - name: Switch to target branch
        if: ${{ always() }}
        shell: bash
        run: |
          set -euo pipefail
          BR='${{ steps.branch.outputs.branch }}'
          echo "Switching to branch: $BR"
          git fetch origin "$BR" --depth=1 || true
          # Prefer remote tracking if it exists; otherwise create/reset local branch
          if git show-ref --verify --quiet "refs/remotes/origin/$BR"; then
            git checkout -B "$BR" "origin/$BR"
          else
            git checkout -B "$BR"
          fi

      - name: Update README badges
        shell: bash
        run: |
          set -euo pipefail
          OWNER='${{ steps.vars.outputs.owner }}'
          REPO='${{ steps.vars.outputs.repo }}'
          LATEST_TAG='${{ steps.vars.outputs.latest_tag }}'

          VERSION_IMG="https://jitpack.io/v/${OWNER}/${REPO}.svg"
          if [ -n "$LATEST_TAG" ]; then
            VERSION_LINK="https://jitpack.io/#${OWNER}/${REPO}:${LATEST_TAG}"
          else
            VERSION_LINK="https://jitpack.io/#${OWNER}/${REPO}"
          fi
          BUILD_IMG="https://jitpack.io/build/${OWNER}/${REPO}.svg"
          BUILD_LINK="https://jitpack.io/#${OWNER}/${REPO}"

          BADGE_BLOCK_START='<!-- JITPACK BADGES:START -->'
          BADGE_BLOCK_END='<!-- JITPACK BADGES:END -->'
          VERSION_MD="[![JitPack](${VERSION_IMG})](${VERSION_LINK})"
          BUILD_MD="[![Build (master)](${BUILD_IMG})](${BUILD_LINK})"

          NEW_BLOCK=$(printf "%s\n%s\n%s\n%s\n" "$BADGE_BLOCK_START" "$VERSION_MD" "$BUILD_MD" "$BADGE_BLOCK_END")

          FILE="README.md"
          if [ ! -f "$FILE" ]; then
            if [ -f "README.MD" ]; then FILE="README.MD"; elif [ -f "README" ]; then FILE="README"; fi
          fi

          if [ ! -f "$FILE" ]; then
            TITLE="# ${REPO}"
            printf "%s\n\n%s\n\n" "$TITLE" "$NEW_BLOCK" > README.md
          else
            if grep -q "$BADGE_BLOCK_START" "$FILE"; then
              awk -v start="$BADGE_BLOCK_START" -v end="$BADGE_BLOCK_END" -v repl="$NEW_BLOCK" '
                BEGIN{inblk=0}
                index($0,start){print repl; inblk=1; next}
                index($0,end){inblk=0; next}
                inblk{next}
                /\[!\[JitPack\]\(https:\/\/jitpack\.io\/v\// {next}
                /\[!\[Build \(master\)\]\(https:\/\/jitpack\.io\/build\// {next}
                {print}
              ' "$FILE" > "$FILE.tmp"
            else
              CONTENT=$(cat "$FILE")
              printf "%s\n\n%s\n" "$NEW_BLOCK" "$CONTENT" > "$FILE.tmp"
              awk 'BEGIN{inblk=0}
                /<!-- JITPACK BADGES:START -->/{inblk=1}
                /<!-- JITPACK BADGES:END -->/{inblk=0}
                {print}
              ' "$FILE.tmp" | awk '
                BEGIN{inblk=0}
                /<!-- JITPACK BADGES:START -->/{inblk=1}
                /<!-- JITPACK BADGES:END -->/{inblk=0}
                inblk{print; next}
                /\[!\[JitPack\]\(https:\/\/jitpack\.io\/v\// {next}
                /\[!\[Build \(master\)\]\(https:\/\/jitpack\.io\/build\// {next}
                {print}
              ' > "$FILE.tmp2" && mv "$FILE.tmp2" "$FILE.tmp"
            fi
            mv "$FILE.tmp" "$FILE"
          fi

      - name: Commit changes if any
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(readme): ensure JitPack badges (latest tag + master build)"
          branch: ${{ steps.branch.outputs.branch }}
          commit_user_name: github-actions[bot]
          commit_user_email: 41898282+github-actions[bot]@users.noreply.github.com
          commit_author: AndreLesa <3635843+AndreLesa@users.noreply.github.com>
          file_pattern: |
            README*

      - name: Trigger JitPack build (master)
        if: github.ref == 'refs/heads/master'
        shell: bash
        run: |
          set -euo pipefail
          OWNER='${{ steps.vars.outputs.owner }}'
          REPO='${{ steps.vars.outputs.repo }}'
          ARTIFACT=$(grep -E '^POM_SETTING_ARTIFACT_ID=' gradle.properties | sed 's/^[^=]*=//' || true)
          if [ -z "$ARTIFACT" ]; then ARTIFACT="$REPO"; fi

          URL_DIR="https://jitpack.io/com/github/${OWNER}/${REPO}/master-SNAPSHOT/"
          URL_POM="https://jitpack.io/com/github/${OWNER}/${REPO}/master-SNAPSHOT/${ARTIFACT}-master-SNAPSHOT.pom"
          URL_BADGE="https://jitpack.io/build/${OWNER}/${REPO}.svg"

          echo "Pinging JitPack to trigger initial master build..."
          # Hit the directory and an expected POM path to trigger build; ignore failures
          (curl -fsSIL "$URL_DIR" || true) >/dev/null
          (curl -fsSIL "$URL_POM" || true) >/dev/null
          # Also touch the build badge (may warm cache)
          (curl -fsSIL "$URL_BADGE" || true) >/dev/null
          echo "Pinged: $URL_DIR and $URL_POM"
